\documentclass[11pt, answers]{exam}
\renewcommand{\baselinestretch}{1.05}
\usepackage{amsmath,amsthm,verbatim,amssymb,amsfonts,amscd, graphicx}
\usepackage{graphics}

\usepackage{afterpage}
\usepackage{caption}

\usepackage{tikz}
\usepackage{fancybox}

\usepackage{clrscode3e}

\topmargin0.0cm
\headheight0.0cm
\headsep0.0cm
\oddsidemargin0.0cm
\textheight23.0cm
\textwidth16.5cm
\footskip1.0cm
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem*{surfacecor}{Corollary 1}
\newtheorem{conjecture}{Conjecture}  
\theoremstyle{definition}
\newtheorem{definition}{Definition}

 \begin{document}
 


\title{CSC263: Assignment 2}
\date{February 9th, 2017}
\author{Junjie Cheng, Jiayun Liu, Zi Hao Lin}
\maketitle

\unframedsolutions

\begin{questions}
\question
%Question1
\begin{solution}
\begin{parts}
\part The auxiliary information is the following:

id: an int represent the id of the thread.

status: a character which is one of ${A, R, S}$, representing the status of the thread.

hasR: a Boolean indicating whether any node in the tree rooted at the current node represents a thread with status $R$.


\end{parts}
\end{solution}

\question
%Question2
\begin{solution}
\begin{parts}
\part 
Since $h_1$ and $h_2$ are both under SUHA,  $prob(h_1(x) empty) = prob(h_1(x) empty) = \frac{k}{m} $ . x will not be inserted into an empty slot only if both $h_1(x)$ and $h_2(x)$ are not empty, otherwise x will choose the shorter chain, i.e. an empty slot. Therefore, the probability for x being inserted into an empty slot is $1-{(\frac{m-k}{m})}^2$.
\end{parts}
\end{solution}


\question
%Question3
\begin{solution}
\begin{enumerate}
\item A Hash table of size $?$, containing a dictionary of (String: int), an array of String and an array of int are used in the algorithm. Both arrays have length of $26$.

The assumption: SUHA%, universal hashing%

\item There are $2$ arrays of length $26$, $A$ and $B$, to keep track of the most frequent word beginning with each alphabet and the frequency of that word. (The first element will represent words that begin with letter 'a', the second will represent words that begin with letter 'b', etc.) Initially, each element in $A$ is $null$ and each element in $B$ is $0$. 

When a new word (other than query) is input, we hash it into the hash table of $?$ slots. When putting the word into the hash table, instead of storing the word directly, we store a pointer of a dictionary into the slot. The key of the dictionary is the string of the word and the value is the number of time the word being input (initially the value will be $1$). When the same word is input again, we can find the dictionary in the hash table and then increment the value by $1$. 

After the dictionary is created or updated, we compare the value of the dictionary (i.e. the frequency of the word) with the corresponding highest frequency among the words beginning with the same letter. If the current word has a higher frequency (or has the same frequency but occurs earilier in alphabetical order), then we update the array with the new word and new frequency. 

When a query occurs, the algorithm will return the words in array $A$ one by one, i.e. the most frequent word beginning with each letter in sorted order.

\item 
\end{enumerate}
\end{solution}

\end{questions}



\end{document}
